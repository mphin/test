name: Rule_update
on:
  push:
    branches:
      - main
    paths:
      - 'rules/*.list'
jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Set up time zone
        run: sudo timedatectl set-timezone Asia/Shanghai
      
      - name: Checkout
        uses: actions/checkout@v3

      - name: Get last commit files
        id: last_commit
        run: |
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: Process Rule File
        id: file_list
        run: |
          COMMIT=${{ env.sha }}
          URL="https://api.github.com/repos/${{ github.repository }}/compare/${COMMIT}^...${COMMIT}"
          FILES=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" $URL | jq -r '.files[] | select(.filename | test("^rules/.*\\.list$")) | .filename')

          echo 更新规则文件
          for file in $FILES; do
            # 修正字符
            sed -i 's/＞/>/g' $file
            # 获取变量
            current_date=$(TZ=Asia/Shanghai date '+%Y年%m月%d日%H:%M:%S')
            count=$(grep -v -e '^$' -e '^#' -e '^!' $file | wc -l)
            count_with_unit="${count}条"
            # 修改数量和日期
            sed -i "s/^# 更新: .*/# 更新: $current_date/" $file
            sed -i "s/^# 数量: .*/# 数量: $count_with_unit/" $file
            # 修改规则正序
            temp_file=$(mktemp)
            domain_list=""
            while IFS= read -r line || [[ -n $line ]]; do
              if [[ ! $line =~ ^[!#[:space:]]*$ && $line =~ ^(IP|DOMAIN).* ]]; then
                domain_list="$domain_list"$'\n'"$line"
              else
                if [[ $domain_list ]]; then
                  echo "$domain_list" | sort | sed '/^$/d' >> "$temp_file"
                  domain_list=""
                fi
                echo "$line" >> "$temp_file"
              fi
            done < "$file"
            if [[ $domain_list ]]; then
              echo "$domain_list" | sort | sed '/^$/d' >> "$temp_file"
            fi
            mv "$temp_file" "$file"
           # 转换Classical规则
           mkdir -p rules/classical
           cp "$file" "rules/classical/$(basename $file .list).yaml"
           sed -i '1s/^/payload:\n/' "rules/classical/$(basename $file .list).yaml"
           sed -i '1!{/^DOMAIN\|^IP\|^PROCESS/!d; s/^/  - /}' "rules/classical/$(basename $file .list).yaml"
           # 排序Classical规则
           { head -n 1 "rules/classical/$(basename $file .list).yaml"; tail -n +2 "rules/classical/$(basename $file .list).yaml" | sort; } > "rules/classical/$(basename $file .list).yaml.sorted"
           mv "rules/classical/$(basename $file .list).yaml.sorted" "rules/classical/$(basename $file .list).yaml"
           
           # 转换singbox规则
           # 定义JSON文件名
           json_file="$(basename "$file" .list).json"

           # 创建JSON文件并写入初始内容
           echo "{" > "$json_file"
           echo '    "version": 1,' >> "$json_file"
           echo '    "rules": {' >> "$json_file"

           # 初始化变量
           domain_values=""
           domain_suffix_values=""
           ip_cidr_values=""
           domain_keyword_values=""

           # 处理文件内容
           while IFS= read -r line; do
               # 跳过空行和注释行
               if [[ -z "$line" || "$line" == \#* ]]; then
                   continue
               fi

               # 处理DOMAIN行
               if [[ "$line" == DOMAIN,* ]]; then
                   domain=$(echo "$line" | cut -d, -f2)
                   domain_values="$domain_values \"$domain\","
               fi

               # 处理DOMAIN-SUFFIX行
               if [[ "$line" == DOMAIN-SUFFIX,* ]]; then
                   domain_suffix=$(echo "$line" | cut -d, -f2)
                   domain_suffix=".$domain_suffix"
                   domain_suffix_values="$domain_suffix_values \"$domain_suffix\","
               fi

               # 处理IP-CIDR行
               if [[ "$line" == IP-CIDR,* ]]; then
                   ip_cidr=$(echo "$line" | cut -d, -f2)
                   ip_cidr=$(echo "$ip_cidr" | sed 's/,no-resolve//g')
                   ip_cidr_values="$ip_cidr_values \"$ip_cidr\","
               fi

               # 处理DOMAIN-KEYWORD行
               if [[ "$line" == DOMAIN-KEYWORD,* ]]; then
                   domain_keyword=$(echo "$line" | cut -d, -f2)
                   domain_keyword_values="$domain_keyword_values \"$domain_keyword\","
               fi
           done < "$file"

           # 添加值到JSON文件
           echo '        "domain": [' >> "$json_file"
           echo "${domain_values%,}" >> "$json_file"
           echo '        ],' >> "$json_file"

           echo '        "domain_suffix": [' >> "$json_file"
           echo "${domain_suffix_values%,}" >> "$json_file"
           echo '        ],' >> "$json_file"

           echo '        "ip_cidr": [' >> "$json_file"
           echo "${ip_cidr_values%,}" >> "$json_file"
           echo '        ],' >> "$json_file"

           echo '        "domain_keyword": [' >> "$json_file"
           echo "${domain_keyword_values%,}" >> "$json_file"
           echo '        ]' >> "$json_file"

           # 添加JSON文件结束标记
           echo '    }' >> "$json_file"
           echo "}" >> "$json_file"
          done

          echo 更新README.md
          new_date=$(TZ='Asia/Shanghai' date +'%Y年%m月%d日%H:%M:%S')
          count_1=$(grep -v -e '^$' -e '^#' -e '^!' rules/*.list | grep -v 'Adblack.list' | wc -l)
          sed -i "s/最近更新: .*/最近更新: $new_date/" README.md
          sed -i "s/规则数量: .*/规则数量: $count_1条/" README.md
          
      - name: Commit And Push
        run: |
          git config --global user.email "long632450362@qq.com" && git config --global user.name "Bot"
          git add . && git commit -m "日常更新$(date +'%Y-%m-%d %H:%M')"
          git push

      - name: Cleanup Workflow
        uses: Mattraks/delete-workflow-runs@main
        with:
          retain_days: 1
          keep_minimum_runs: 2
